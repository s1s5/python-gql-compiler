# @generated AUTOGENERATED file. Do not Change!
# flake8: noqa
# fmt: off
# isort: skip_file

import typing
import copy
from dataclasses import dataclass
from gql import gql, Client
import datetime


def rewrite_typename(value: typing.Any):
    if isinstance(value, dict) and '__typename' in value:
        value = copy.copy(value)
        value['_typename'] = value.pop('__typename')
    return value



@dataclass
class GetScalarResponse:
    hello: str


_GetScalarInput__required = typing.TypedDict("_GetScalarInput__required", {})
_GetScalarInput__not_required = typing.TypedDict("_GetScalarInput__not_required", {}, total=False)


class _GetScalarInput(_GetScalarInput__required, _GetScalarInput__not_required):
    pass


class GetScalar:
    Response = GetScalarResponse
    Input = _GetScalarInput
    _query = gql('''
        query GetScalar {
          hello
        }
    ''')
    @classmethod
    def execute(cls, client: Client, variable_values: _GetScalarInput = {}) -> GetScalarResponse:
        return cls.Response(**rewrite_typename(client.execute(  # type: ignore
            cls._query, variable_values=variable_values
        )))
    @classmethod
    async def execute_async(cls, client: Client, variable_values: _GetScalarInput = {}) -> typing.Awaitable[GetScalarResponse]:
        return cls.Response(**rewrite_typename(await client.execute_async(  # type: ignore
            cls._query, variable_values=variable_values
        )))
Episode = typing.Literal["NEWHOPE", "EMPIRE", "JEDI"]


@dataclass
class GetObject__droid:
    id: str
    name: str
    appearsIn: typing.List[Episode]
    primaryFunction: str


@dataclass
class GetObjectResponse:
    droid: GetObject__droid
    def __init__(self, droid):
        self.droid = GetObject__droid(**rewrite_typename(droid))


_GetObjectInput__required = typing.TypedDict("_GetObjectInput__required", {"id": str})
_GetObjectInput__not_required = typing.TypedDict("_GetObjectInput__not_required", {}, total=False)


class _GetObjectInput(_GetObjectInput__required, _GetObjectInput__not_required):
    pass


class GetObject:
    Response = GetObjectResponse
    Input = _GetObjectInput
    _query = gql('''
        query GetObject($id: ID!) {
          droid(id: $id) {
            id name appearsIn primaryFunction
          }
        }
    ''')
    @classmethod
    def execute(cls, client: Client, variable_values: _GetObjectInput) -> GetObjectResponse:
        return cls.Response(**rewrite_typename(client.execute(  # type: ignore
            cls._query, variable_values=variable_values
        )))
    @classmethod
    async def execute_async(cls, client: Client, variable_values: _GetObjectInput) -> typing.Awaitable[GetObjectResponse]:
        return cls.Response(**rewrite_typename(await client.execute_async(  # type: ignore
            cls._query, variable_values=variable_values
        )))


@dataclass
class GetInterface__hero:
    id: str
    name: str


@dataclass
class GetInterfaceResponse:
    hero: GetInterface__hero
    def __init__(self, hero):
        self.hero = GetInterface__hero(**rewrite_typename(hero))


_GetInterfaceInput__required = typing.TypedDict("_GetInterfaceInput__required", {"e": Episode})
_GetInterfaceInput__not_required = typing.TypedDict("_GetInterfaceInput__not_required", {}, total=False)


class _GetInterfaceInput(_GetInterfaceInput__required, _GetInterfaceInput__not_required):
    pass


class GetInterface:
    Response = GetInterfaceResponse
    Input = _GetInterfaceInput
    _query = gql('''
        query GetInterface($e: Episode!) {
          hero(episode: $e) {
            id name
          }
        }
    ''')
    @classmethod
    def execute(cls, client: Client, variable_values: _GetInterfaceInput) -> GetInterfaceResponse:
        return cls.Response(**rewrite_typename(client.execute(  # type: ignore
            cls._query, variable_values=variable_values
        )))
    @classmethod
    async def execute_async(cls, client: Client, variable_values: _GetInterfaceInput) -> typing.Awaitable[GetInterfaceResponse]:
        return cls.Response(**rewrite_typename(await client.execute_async(  # type: ignore
            cls._query, variable_values=variable_values
        )))


@dataclass
class GetInlineFragment__hero__Droid:
    id: str
    name: str
    primaryFunction: str
    _typename: typing.Literal["Droid"]


@dataclass
class GetInlineFragment__hero__Human:
    id: str
    name: str
    totalCredits: int
    _typename: typing.Literal["Human"]


@dataclass
class GetInlineFragment__hero:
    id: str
    name: str
    _typename: typing.Literal["Character"]


@dataclass
class GetInlineFragmentResponse:
    hero: GetInlineFragment__hero
    def __init__(self, hero):
        __hero_map = {
            "Human": GetInlineFragment__hero__Human,
            "Droid": GetInlineFragment__hero__Droid,
        }
        self.hero = __hero_map.get(hero["__typename"], GetInlineFragment__hero)(**rewrite_typename(hero))


_GetInlineFragmentInput__required = typing.TypedDict("_GetInlineFragmentInput__required", {"e": Episode})
_GetInlineFragmentInput__not_required = typing.TypedDict("_GetInlineFragmentInput__not_required", {}, total=False)


class _GetInlineFragmentInput(_GetInlineFragmentInput__required, _GetInlineFragmentInput__not_required):
    pass


class GetInlineFragment:
    Response = GetInlineFragmentResponse
    Input = _GetInlineFragmentInput
    _query = gql('''
        query GetInlineFragment($e: Episode!) {
          hero(episode: $e) {
            __typename id name
            ... on Human { totalCredits }
            ... on Droid { primaryFunction }
          }
        }
    ''')
    @classmethod
    def execute(cls, client: Client, variable_values: _GetInlineFragmentInput) -> GetInlineFragmentResponse:
        return cls.Response(**rewrite_typename(client.execute(  # type: ignore
            cls._query, variable_values=variable_values
        )))
    @classmethod
    async def execute_async(cls, client: Client, variable_values: _GetInlineFragmentInput) -> typing.Awaitable[GetInlineFragmentResponse]:
        return cls.Response(**rewrite_typename(await client.execute_async(  # type: ignore
            cls._query, variable_values=variable_values
        )))


@dataclass
class GetCustomScalarResponse:
    today: datetime.date


_GetCustomScalarInput__required = typing.TypedDict("_GetCustomScalarInput__required", {})
_GetCustomScalarInput__not_required = typing.TypedDict("_GetCustomScalarInput__not_required", {}, total=False)


class _GetCustomScalarInput(_GetCustomScalarInput__required, _GetCustomScalarInput__not_required):
    pass


class GetCustomScalar:
    Response = GetCustomScalarResponse
    Input = _GetCustomScalarInput
    _query = gql('''
        query GetCustomScalar {
          today
        }
    ''')
    @classmethod
    def execute(cls, client: Client, variable_values: _GetCustomScalarInput = {}) -> GetCustomScalarResponse:
        return cls.Response(**rewrite_typename(client.execute(  # type: ignore
            cls._query, variable_values=variable_values
        )))
    @classmethod
    async def execute_async(cls, client: Client, variable_values: _GetCustomScalarInput = {}) -> typing.Awaitable[GetCustomScalarResponse]:
        return cls.Response(**rewrite_typename(await client.execute_async(  # type: ignore
            cls._query, variable_values=variable_values
        )))


@dataclass
class GetUnion__search__Starship:
    name: str
    _typename: typing.Literal["Starship"]


@dataclass
class GetUnion__search__Droid__friends:
    name: str


@dataclass
class GetUnion__search__Droid:
    friends: typing.List[typing.Optional[GetUnion__search__Droid__friends]]
    _typename: typing.Literal["Droid"]
    def __init__(self, friends, _typename):
        self.friends = [GetUnion__search__Droid__friends(**rewrite_typename(friends__iter)) if friends__iter else None for friends__iter in friends]
        self._typename = _typename


@dataclass
class GetUnion__search__Human:
    totalCredits: int
    _typename: typing.Literal["Human"]


@dataclass
class GetUnion__search:
    _typename: typing.Literal["SearchResult"]


@dataclass
class GetUnionResponse:
    search: typing.List[GetUnion__search]
    def __init__(self, search):
        __search_map = {
            "Human": GetUnion__search__Human,
            "Droid": GetUnion__search__Droid,
            "Starship": GetUnion__search__Starship,
        }
        self.search = [__search_map.get(search__iter["__typename"], GetUnion__search)(**rewrite_typename(search__iter)) for search__iter in search]


_GetUnionInput__required = typing.TypedDict("_GetUnionInput__required", {"text": str})
_GetUnionInput__not_required = typing.TypedDict("_GetUnionInput__not_required", {}, total=False)


class _GetUnionInput(_GetUnionInput__required, _GetUnionInput__not_required):
    pass


class GetUnion:
    Response = GetUnionResponse
    Input = _GetUnionInput
    _query = gql('''
        query GetUnion($text: String!) {
          search(text: $text) {
            __typename
            ... on Human { totalCredits }
            ... on Droid { friends { name } }
            ... on Starship { name }
          }
        }
    ''')
    @classmethod
    def execute(cls, client: Client, variable_values: _GetUnionInput) -> GetUnionResponse:
        return cls.Response(**rewrite_typename(client.execute(  # type: ignore
            cls._query, variable_values=variable_values
        )))
    @classmethod
    async def execute_async(cls, client: Client, variable_values: _GetUnionInput) -> typing.Awaitable[GetUnionResponse]:
        return cls.Response(**rewrite_typename(await client.execute_async(  # type: ignore
            cls._query, variable_values=variable_values
        )))


@dataclass
class GetRecursive__hero__Droid__friends__Droid__friends:
    name: str


@dataclass
class GetRecursive__hero__Droid__friends__Droid:
    id: str
    name: str
    friends: typing.List[typing.Optional[GetRecursive__hero__Droid__friends__Droid__friends]]
    _typename: typing.Literal["Droid"]
    def __init__(self, id, name, friends, _typename):
        self.id = id
        self.name = name
        self.friends = [GetRecursive__hero__Droid__friends__Droid__friends(**rewrite_typename(friends__iter)) if friends__iter else None for friends__iter in friends]
        self._typename = _typename


@dataclass
class GetRecursive__hero__Droid__friends__Human__starships:
    name: str


@dataclass
class GetRecursive__hero__Droid__friends__Human:
    id: str
    name: str
    starships: typing.List[typing.Optional[GetRecursive__hero__Droid__friends__Human__starships]]
    _typename: typing.Literal["Human"]
    def __init__(self, id, name, starships, _typename):
        self.id = id
        self.name = name
        self.starships = [GetRecursive__hero__Droid__friends__Human__starships(**rewrite_typename(starships__iter)) if starships__iter else None for starships__iter in starships]
        self._typename = _typename


@dataclass
class GetRecursive__hero__Droid__friends:
    id: str
    _typename: typing.Literal["Character"]


@dataclass
class GetRecursive__hero__Droid:
    name: str
    primaryFunction: str
    friends: typing.List[typing.Optional[GetRecursive__hero__Droid__friends]]
    _typename: typing.Literal["Droid"]
    def __init__(self, name, primaryFunction, friends, _typename):
        self.name = name
        self.primaryFunction = primaryFunction
        __friends_map = {
            "Human": GetRecursive__hero__Droid__friends__Human,
            "Droid": GetRecursive__hero__Droid__friends__Droid,
        }
        self.friends = [__friends_map.get(friends__iter["__typename"], GetRecursive__hero__Droid__friends)(**rewrite_typename(friends__iter)) if friends__iter else None for friends__iter in friends]
        self._typename = _typename


@dataclass
class GetRecursive__hero__Human__friends__Droid:
    id: str
    name: str
    _typename: typing.Literal["Droid"]


@dataclass
class GetRecursive__hero__Human__friends__Human:
    name: str
    _typename: typing.Literal["Human"]


@dataclass
class GetRecursive__hero__Human__friends:
    _typename: typing.Literal["Character"]


@dataclass
class GetRecursive__hero__Human:
    name: str
    friends: typing.List[typing.Optional[GetRecursive__hero__Human__friends]]
    _typename: typing.Literal["Human"]
    def __init__(self, name, friends, _typename):
        self.name = name
        __friends_map = {
            "Human": GetRecursive__hero__Human__friends__Human,
            "Droid": GetRecursive__hero__Human__friends__Droid,
        }
        self.friends = [__friends_map.get(friends__iter["__typename"], GetRecursive__hero__Human__friends)(**rewrite_typename(friends__iter)) if friends__iter else None for friends__iter in friends]
        self._typename = _typename


@dataclass
class GetRecursive__hero:
    name: str
    _typename: typing.Literal["Character"]


@dataclass
class GetRecursiveResponse:
    hero: GetRecursive__hero
    def __init__(self, hero):
        __hero_map = {
            "Human": GetRecursive__hero__Human,
            "Droid": GetRecursive__hero__Droid,
        }
        self.hero = __hero_map.get(hero["__typename"], GetRecursive__hero)(**rewrite_typename(hero))


_GetRecursiveInput__required = typing.TypedDict("_GetRecursiveInput__required", {"episode": Episode})
_GetRecursiveInput__not_required = typing.TypedDict("_GetRecursiveInput__not_required", {}, total=False)


class _GetRecursiveInput(_GetRecursiveInput__required, _GetRecursiveInput__not_required):
    pass


class GetRecursive:
    Response = GetRecursiveResponse
    Input = _GetRecursiveInput
    _query = gql('''
        query GetRecursive($episode: Episode!) {
          hero(episode: $episode) {
            __typename
            name
            ... on Human {
              friends {
                __typename
                ... on Human { name }
                ... on Droid { id name }
              }
            }
            ... on Droid {
              primaryFunction
              friends {
                __typename
                id
                ... on Human {
                  name
                  starships { name }
                }
                ... on Droid {
                  name
                  friends { name }
                }
              }
            }
          }
        }
    ''')
    @classmethod
    def execute(cls, client: Client, variable_values: _GetRecursiveInput) -> GetRecursiveResponse:
        return cls.Response(**rewrite_typename(client.execute(  # type: ignore
            cls._query, variable_values=variable_values
        )))
    @classmethod
    async def execute_async(cls, client: Client, variable_values: _GetRecursiveInput) -> typing.Awaitable[GetRecursiveResponse]:
        return cls.Response(**rewrite_typename(await client.execute_async(  # type: ignore
            cls._query, variable_values=variable_values
        )))


AddStarshipInput__required = typing.TypedDict("AddStarshipInput__required", {"name": str})
AddStarshipInput__not_required = typing.TypedDict("AddStarshipInput__not_required", {}, total=False)


class AddStarshipInput(AddStarshipInput__required, AddStarshipInput__not_required):
    pass


@dataclass
class AddStarship__addStarship:
    id: str
    name: str


@dataclass
class AddStarshipResponse:
    addStarship: AddStarship__addStarship
    def __init__(self, addStarship):
        self.addStarship = AddStarship__addStarship(**rewrite_typename(addStarship))


_AddStarshipInput__required = typing.TypedDict("_AddStarshipInput__required", {"input": AddStarshipInput})
_AddStarshipInput__not_required = typing.TypedDict("_AddStarshipInput__not_required", {}, total=False)


class _AddStarshipInput(_AddStarshipInput__required, _AddStarshipInput__not_required):
    pass


class AddStarship:
    Response = AddStarshipResponse
    Input = _AddStarshipInput
    _query = gql('''
        mutation AddStarship($input: AddStarshipInput!) {
          addStarship(input: $input) {
            id name
          }
        }
    ''')
    @classmethod
    def execute(cls, client: Client, variable_values: _AddStarshipInput) -> AddStarshipResponse:
        return cls.Response(**rewrite_typename(client.execute(  # type: ignore
            cls._query, variable_values=variable_values
        )))
    @classmethod
    async def execute_async(cls, client: Client, variable_values: _AddStarshipInput) -> typing.Awaitable[AddStarshipResponse]:
        return cls.Response(**rewrite_typename(await client.execute_async(  # type: ignore
            cls._query, variable_values=variable_values
        )))


@dataclass
class AllHuman__allHuman:
    id: str
    name: str


@dataclass
class AllHumanResponse:
    allHuman: AllHuman__allHuman
    def __init__(self, allHuman):
        self.allHuman = AllHuman__allHuman(**rewrite_typename(allHuman))


_AllHumanInput__required = typing.TypedDict("_AllHumanInput__required", {})
_AllHumanInput__not_required = typing.TypedDict("_AllHumanInput__not_required", {}, total=False)


class _AllHumanInput(_AllHumanInput__required, _AllHumanInput__not_required):
    pass


class AllHuman:
    Response = AllHumanResponse
    Input = _AllHumanInput
    _query = gql('''
        subscription AllHuman {
          allHuman {
            id name
          }
        }
    ''')
    @classmethod
    def subscribe(cls, client: Client, variable_values: _AllHumanInput = {}) -> typing.Iterable[AllHumanResponse]:
        for r in client.subscribe(cls._query, variable_values=variable_values):
            yield cls.Response(**rewrite_typename(r))  # type: ignore
    @classmethod
    async def subscribe_async(cls, client: Client, variable_values: _AllHumanInput = {}) -> typing.AsyncIterable[AllHumanResponse]:
        async for r in client.subscribe_async(cls._query, variable_values=variable_values):
            yield cls.Response(**rewrite_typename(r))  # type: ignore
